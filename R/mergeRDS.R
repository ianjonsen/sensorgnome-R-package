## go through all YEAR_PROJECT_SITE_alltags.rds files in the /SG/contrib/YEAR hierarchy
## and merge them into a single table database /SG/YEAR_alltags.sqlite
## omit "2012" tags for now

mergeRDS = function(year) {
  library(RSQLite)
  library(lubridate)
  files = dir(sprintf("/SG/contrib/%d", year),
    pattern = sprintf("^%d_.*_alltags.rds", year),
    full.names = TRUE,
    recursive = TRUE)

  ## read in tag deployment file for species code
  tagdeps = read.csv(sprintf("/SG/%d_tag_deployments.csv", year), as.is=TRUE)

  ## generate a uid, which uniquely identifies the physical tag
  ## (for now, we know that no project has more than one tag of the same ID and frequency)
  uid = sprintf("%s#%03d@%.3f", tagdeps$proj, tagdeps$tagID, tagdeps$tag.freq)
                                                 
  ## spcodes is a list, whose names are the uid generated above
  ## each element of the list is a 
  dups = which(duplicated(uid))
  ii = 1
  suffixes = c('a', 'b', 'c', 'd', 'e', 'f', 'g')
  while(length(dups) > 0) {
    uid[dups] = sub("[a-z]?@", paste(suffixes[ii], '@', sep=""), uid[dups])
    dups = which(duplicated(uid))
    ii = ii + 1
  }
  rownames(tagdeps) = uid
  
  ## drop files generated by running against 2012 tag database
  files = grep("2012", invert=TRUE, value=TRUE, files)

  ## create / connect to database
  
##  con = dbConnect("SQLite", sprintf("/media/SG_Data/new_%d_alltags.sqlite", year))
  finalDB = sprintf("/SG/new_%d_alltags.sqlite", year)
  con = dbConnect("SQLite", ":memory:")

  dbGetQuery(con, "pragma journal_mode=truncate;")
  dbGetQuery(con, "pragma synchronous=2;")
  dbGetQuery(con, "pragma locking_mode=exclusive;")
  
  dbGetQuery(con, "drop table if exists tags")
  dbGetQuery(con, "CREATE TABLE tags 
( ant TEXT,
 ts REAL,
 fullID TEXT,
 freq REAL,
 freqsd REAL,
 sig REAL,
 sigsd REAL,
 noise REAL,
 runID REAL,
 posInRun INTEGER,
 slop REAL,
 burstSlop REAL,
 antFreq REAL,
 tsOrig REAL,
 bootnum INTEGER,
 runLen INTEGER,
 id REAL,
 tagProj TEXT,
 nomFreq REAL,
 lat REAL,
 lon REAL,
 alt REAL,
 depYear INTEGER,
 proj TEXT,
 site TEXT,
 recv TEXT,
 sp TEXT,
 label TEXT,
 fullSite TEXT,
 gain REAL,
 dbm REAL,
 crossFreq INTEGER,
 tagFreq REAL 
 )")

  ## target column names

  colNames = c("ant", "ts", "fullID", "freq", "freqsd", "sig", "sigsd", "noise",  "runID", "posInRun", "slop", "burstSlop", "antFreq", "tsOrig",  "bootnum", "runLen", "id", "tagProj", "nomFreq", "lat", "lon",  "alt", "depYear", "proj", "site", "recv", "sp", "label", "fullSite", "gain", "dbm", "crossFreq", "tagFreq" )
  
  nrows = 0
  cumRunID = 0
  for (f in files) {
    x = readRDS(f)
    if (is.factor(x$id))
      x$id = as.integer(as.character(x$id))
    
    ## make sure run IDs are unique across all sites
    x$runID = x$runID + cumRunID
    cumRunID = max(x$runID)

    ## tag IDs above 8000 are cross-frequency (detections at 166.380 of tags at 166.300)
    ## mark these and correct the id
    x$crossFreq = x$id > 8000
    x$id = x$id %% 1000

    ## generate nominal antenna frequency
    if (! "nomFreq" %in% names(x))
      x$nomFreq = ifelse(x$antFreq > 166.37, 166.380, 166.300)
    
    ## generate a missing tagFreq column, which is the same as nomFreq (the
    ## nominal receiver frequency), except for cross frequency detections
    
    ## generate missing tagFreq column
    if (! "tagFreq" %in% names(x))
      x$tagFreq = x$nomFreq - ifelse(x$crossFreq, 0.080, 0)
    
    ## add missing gain column
    if (! "gain" %in% names(x))
      x$gain = 0

    ## add missing dbm column (SG only)
    if (! "dbm" %in% names(x))
      x$dbm = sgPowerTodBm(x$sig, x$gain)

    ## add missing altitude column
    if (! "alt" %in% names(x))
      x$alt = NA
    
    ## convert bogus lat/lon to NA
    noLL = which(x$lat == 999)
    x$lat[noLL] = NA
    x$lon[noLL] = NA
    x$alt[noLL] = NA

    ## generate missing fullSite column
    if (! "fullSite" %in% names(x))
      x$fullSite = as.factor(sprintf("%.1f, %.1f (%s)", round(x$lat, 1), round(x$lon, 1), x$site))

    ## generate correct species code
    x$sp = tagdeps[sprintf("%s#%03d@%.3f", x$tagProj, x$id, x$tagFreq), "spcd"]

    ## generate clean tag label
    x$label = sprintf("%s %03d @ %.3f-%s", x$sp, x$id, x$nomFreq - ifelse(x$crossFreq, 0.080, 0), x$tagProj)

    ## write table with columns in correct order, since dbWriteTable makes
    ## no attempt to match column names between existing DB table and table
    ## being written

    dbWriteTable(con, "tags", x[, match(colNames, names(x))], row.names=FALSE, append=TRUE)

    print(dbGetQuery(con, "pragma integrity_check"))

    nrows = nrows + nrow(x)
    cat (f, " ", nrows, "\n")
  }


  dbGetQuery(con, paste("attach \"", finalDB, "\" as final", sep=""))
  dbGetQuery(con, "create table final.tags as select * from tags")

  dbGetQuery(con, "create index final.tags_ts on tags ( ts )")
  cat("created index tags_ts\n")
  dbGetQuery(con, "create index final.tags_fullID on tags ( fullID )")
  cat("created index tags_fullID\n")
  dbGetQuery(con, "create index final.tags_idproj on tags ( id, tagProj )")
  cat("created index tags_idproj\n")
  dbGetQuery(con, "create index final.tags_fullSite on tags ( fullSite )")
  cat("created index tags_fullSite\n")
  dbGetQuery(con, "create index final.tags_tagProj on tags ( tagProj )")
  cat("created index tags_tagProj\n")
  dbGetQuery(con, "create index final.tags_id on tags ( id )")
  cat("created index tags_id\n")
  dbGetQuery(con, "detach database final")

  dbDisconnect(con)
}

  
  
